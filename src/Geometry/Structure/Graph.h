#ifndef DRAGON_GRAPH_H
#define DRAGON_GRAPH_H
#include "Geometry/BasicGeometry.h"
#include "Geometry/Structure/KDTree.h"
#include <algorithm>

namespace dragon
{
namespace geometry
{
// currently only for 3D points
class Graph 
{
    // generated by ChatGPT
    public:
        Graph() = default;
        Graph(const geometry::Point3List& points) 
        {
            for (const auto& p : points) 
            {
                vertices.push_back(p);
                neighbors.push_back(std::vector<size_t>());
            }
        }

        void ConstructEdgeThreshold(double threshold)
        {
            for (size_t i = 0; i < vertices.size(); i++) 
                for (size_t j = i + 1; j < vertices.size(); j++) 
                    if (geometry::Distance(vertices[i], vertices[j]) <= threshold) 
                    {
                        AddEdge(i, j);
                        AddEdge(j, i);
                    }
        }
        void ConstructEdgeThreshold(const std::vector<double> & radius)
        {
            for (size_t i = 0; i < vertices.size(); i++) 
                for (size_t j = i + 1; j < vertices.size(); j++) 
                    if (geometry::Distance(vertices[i], vertices[j]) <= radius[i] || geometry::Distance(vertices[i], vertices[j]) <= radius[j]) 
                    {
                        AddEdge(i, j);
                        AddEdge(j, i);
                    }
        }
        void ConstructEdgeKNN(int k)
        {
            geometry::KDTree<3> kdtree;
            kdtree.BuildTree(vertices);
            std::vector<size_t> indices;
            std::vector<float> dists;
            for (size_t i = 0; i < vertices.size(); ++i)
            {
                kdtree.KnnSearch(vertices[i], indices, dists, k);
                for (size_t j = 1; j < indices.size(); ++j)
                {
                    AddEdge(i, indices[j]);
                    AddEdge(indices[j], i);
                }
            }
        }
        void ConstructEdgeAdaptive(double factor = 2, int max_k = 10)
        {
            geometry::KDTree<3> kdtree;
            kdtree.BuildTree(vertices);
            std::vector<size_t> indices;
            std::vector<float> dists;
            for (size_t i = 0; i < vertices.size(); ++i)
            {
                kdtree.KnnSearch(vertices[i], indices, dists, max_k);
                if(indices.size() <= 1)
                {
                    std::cout<<YELLOW<<"[WARNING]::[GRAPH]::Single vertex in graph."<<RESET<<std::endl;
                    continue;
                }
                AddEdge(i, indices[1]);
                AddEdge(indices[1], i);
                geometry::Vec3List directions;
                directions.push_back((vertices[indices[1]] -  vertices[i]).normalized());
                for (size_t j = 2; j < indices.size(); ++j)
                {
                    geometry::Vector3 tmp_d = (vertices[indices[j]] -  vertices[i]).normalized();
                    bool new_direction = true;
                    for(auto &d: directions)
                    {
                       if(tmp_d.dot(d) > 0.75)
                        {
                            new_direction = false;
                            break;
                        }
                    }
                    if(dists[j] / dists[1] <= factor * factor|| new_direction)
                    {
                        AddEdge(i, indices[j]);
                        AddEdge(indices[j], i);
                        directions.push_back(tmp_d);
                    }
                    else break;
                }
            }
        }
        
        void AddEdge(size_t u, size_t v) 
        {
            if(std::find(neighbors[u].begin(), neighbors[u].end(), v) == neighbors[u].end())
            {
                neighbors[u].push_back(v);
            }
        }
        
        const std::vector<size_t>& GetNeighbors(size_t vertex_id) const 
        {
            return neighbors[vertex_id];
        }
        const std::vector<std::vector<size_t>>& GetNeighbors() const
        {
            return neighbors;
        }
        
        
    private:
        
        geometry::Point3List vertices;
        std::vector<std::vector<size_t>> neighbors;
};
}
}

#endif